use std::env;
use std::fs;
use fortran_lexer::{tokenize, detect_format, TokenType};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <fortran-file>", args[0]);
        std::process::exit(1);
    }
    
    let file_path = &args[1];
    let source = fs::read_to_string(file_path)?;
    
    println!("=== FERRUM DOCUMENTATION EXTRACTOR ===");
    println!("Extracting documentation from: {}", file_path);
    
    // Use Ferrum lexer to extract comments
    let format = detect_format(&source);
    let tokens = tokenize(&source, format)?;
    
    let mut comments = Vec::new();
    for token in tokens {
        if let TokenType::Comment(comment_text) = token.token_type {
            comments.push((token.line, comment_text));
        }
    }
    
    println!("\n=== EXTRACTED DOCUMENTATION ===");
    println!("Total comment lines: {}", comments.len());
    
    // Extract key sections
    let mut current_section = String::new();
    let mut in_parameters = false;
    let mut in_description = false;
    
    for (_line, comment) in &comments {
        let clean_comment = comment.trim_start_matches(['c', 'C', '*', '!']).trim();
        
        if clean_comment.contains("PARAMETERS") {
            in_parameters = true;
            println!("\n### PARAMETERS");
            continue;
        }
        
        if clean_comment.contains("DESCRIPTION") {
            in_description = true;
            println!("\n### DESCRIPTION");
            continue;
        }
        
        if clean_comment.contains("PURPOSE") {
            println!("\n### PURPOSE");
            continue;
        }
        
        if clean_comment.contains("KEYWORDS") {
            println!("\n### KEYWORDS");
            continue;
        }
        
        if !clean_comment.is_empty() && !clean_comment.starts_with("---") {
            println!("{}", clean_comment);
        }
    }
    
    // Generate modern documentation
    println!("\n\n=== MODERN DOCUMENTATION (Generated by Ferrum) ===");
    println!("```rust");
    println!("/// Numerical Jacobian computation using finite differences");
    println!("///");
    println!("/// Computes the Jacobian matrix for a system of M equations in N variables");
    println!("/// using finite difference approximations. Designed for use in numerical");
    println!("/// methods for solving nonlinear problems where a Jacobian is evaluated");
    println!("/// repeatedly at neighboring arguments.");
    println!("///");
    println!("/// # Arguments");
    println!("/// * `mode` - Control flag for reverse communication");
    println!("/// * `m` - Number of equations");
    println!("/// * `n` - Number of variables");
    println!("/// * `y` - Current function values");
    println!("/// * `fjac` - Output Jacobian matrix");
    println!("/// * `yscale` - Scaling factors for variables");
    println!("/// * `fac` - Finite difference step sizes");
    println!("///");
    println!("/// # Returns");
    println!("/// Result indicating success or failure");
    println!("pub fn fortran_function(");
    println!("    // Parameters extracted from FORTRAN");
    println!("    // ... (specific parameters depend on input file)");
    println!(") -> Result<(), Error> {{");
    println!("    // Modern implementation");
    println!("}}");
    println!("```");
    
    Ok(())
}